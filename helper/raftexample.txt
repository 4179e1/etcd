func (rc *raftNode)raftNode.replayWAL()  *wal.WAL 
|-snapshot ：= raftNode.loadSnapshot()       - 从snap文件中找到最后一个并加载（如果有的话），里面记录了term和index
|- w := raftNode.openWAL(snapshot)           
| |-wal.Create (rc.waldir) if ! wal.Exit(rc.waldir) 如果不存在WAL目录/文件则创建，wal文件名为<seq>-<index>.wal
| |-wal.Open(sanpshot)          找到最后一个index <= snapshot.index的wal并打开，注意wal.decoder会一直加载后续的wal文件，直到EOF
|- _, st, ents, err := w.ReadAll()                     读取所有日志，真正开始读取WAL
|- rc.raftStorage = raft.NewMemoryStorage()            //新建raft存储，状态机？
|- rc.raftStorage.ApplySnapshot (*snapshot) if snapshot != nil   // 回放快照? 不，它只是更新了一些metadata，实际snapshot的加载还是应用状态机做的，见Kvstore.readCommits()
|- rc.raftStorage.SetHartState (st)                              // 设置状态
|- rc.raftStorage.Append (ents)                                  // 回放wal日志
|- rc.lastIndex = ents[len(ents)-1].Index in len(ents) > 0 else rc.commitC <- nil // send nil once lastIndex is published so client knows commit channel is current, 在首次启动的时候触发.

func (rc *raftNode) maybeTriggerSnapshot() 
|- return if rc.appliedIndex - rc.snapshotIndex <= rc.snapCount //如果applied index和上一次snapshot的Index之间的条数少于snapCount则跳过snapshot的创建
|- data := rc.getSnapshot()  从应用获取snapshot数据，这个函数是个closure，见main 函数里面的getSnapshot
|- snap := rc.raftStorage.CreateSnapshot (rc.appliedIndex i , &rc.confState cs, data)
|  |- return ErrSnapOutOfDate if i <= ms.snapshot.Metadata.Index //快照过期
|  |- panic if i > ms.lastIndex() // 快照超出自身entry的边界
|  |- s.snapshot.Metadata.Index = i
|  |- s.snapshot.Metadata.Term = ms.ents[i- ms.ents[0].Index].Term //  snapshot 所在index的条目的term
|  |- s.snapshot.Meatadata.ConfState = *cs if cs != nil  //更新ConfState
|  |- ms.snapshot.Data = data   //更新快照数据
|  |- return ms.snapshot
|- rc.saveSnap (snap)
|  |- TODO