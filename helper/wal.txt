See: https://my.oschina.net/fileoptions/blog/1825531
     https://blog.zhesih.com/2017/10/03/the-wal-files-in-etcd-v3/
Reference: https://work.tinou.com/2012/09/write-ahead-log.html

- wal/walpb/record.pb.go

Type: 
	metadataType int64 = iota + 1
	entryType
	stateType
	crcType
	snapshotType

type Record struct {
	Type             int64  `protobuf:"varint,1,opt,name=type" json:"type"`
	Crc              uint32 `protobuf:"varint,2,opt,name=crc" json:"crc"`
	Data             []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

type Snapshot struct {
	Index            uint64 `protobuf:"varint,1,opt,name=index" json:"index"`
	Term             uint64 `protobuf:"varint,2,opt,name=term" json:"term"`
	XXX_unrecognized []byte `json:"-"`
}

- wal/wal.go
type WAL struct {
	lg *zap.Logger

	dir string // the living directory of the underlay files

	// dirFile is a fd for the wal directory for syncing on Rename
	dirFile *os.File

	metadata []byte           // metadata recorded at the head of each WAL
	state    raftpb.HardState // hardstate recorded at the head of WAL

	start     walpb.Snapshot // snapshot to start reading
	decoder   *decoder       // decoder to decode records
	readClose func() error   // closer for decode reader

	mu      sync.Mutex
	enti    uint64   // index of the last entry saved to the wal
	encoder *encoder // encoder to encode records

	locks []*fileutil.LockedFile // the locked files the WAL holds (the name is increasing)
	fp    *filePipeline
}

func Create (lg *zap.Logger, dirpath string, metadata []byte) (*WAL, error)
|- Exist (dirpath)
|- tmpdirpath := filepath.Clean(dirpath) + ".tmp"
|- fileutil.CreateDirAll (tmpdirpath)
|- p := filepath.Join (tmpdirpath, walName(0, 0))
|- f := fileutil.LockFile (p, s.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode) // syscall.Flock()
|- f.Seek (0, io.SeekEnd) // go to the end of the file, but why? shouldn't it empty?
|- fileutil.Preallocate(f.File, SegmentSizeBytes, true)
|- w := &WAL {...}
|- w.encoder := newFileEncoder (f.File, prevCrc : 0)
|  |- offset := f.Seek (0, io.SeekCurrent)    // get current offset
|  |- newEncoder (f, prevCrc, pageOffset) 
|     |- see below
|- w.saveCrc(0)
|  |- w.encoder.encode(&walpb.Record{Type: crcType, Crc: prevCrc})
|- w.locks.append (f)               //<--- it's a lock list
|- w.encoder.encode(&walpb.Record{Type: metadataType, Data: metadata})
|- w.SaveSnapshot(walpb.Snapshot{}) //TODO
|  |- b:= pbutil.MustMarshal (&e)
|  |- w.mu.Lock()
|  |- rec := &walpb.Record {Type: snapshotType, Data: b}
|  |- w.encoder.encode (rec)
|  |- w.sync()
|     |- w.encoder.flush()
|     |- fileutil.Fdatasync (w.tail().File)
|        |- Fsync (f)
|        |- syscall.Syscall (syscall.SYS_FCNT, f.Fd(), uintptr(syscall.F_FULLFSYNC), uintptr(0))
|- w = w.renameWAL (tmpdirpath)
|  |- os.RemoveAll (w.dir) // the dir without ".tmp"
|  |- os.Rename (tmpdirpath, w.dir) // For windows, close, rename, open
|  |- w.fp = newFilePipeline (w.lg, w.dir, SegmentSizeBytes)
|  |- w.dirFile = fileutil.OpenDir (w.dir)
|- //directory was renamed; sync parent dir to persist rename...
|- //That's open parent dir, fsync, close


- wal/file_pipeline.go
type filePipeline struct {
	lg *zap.Logger

	// dir to put files
	dir string
	// size of files to make, in bytes
	size int64
	// count number of files generated
	count int

	filec chan *fileutil.LockedFile
	errc  chan error
	donec chan struct{}
}


- wal/encoder.go
func newEncoder(w io.Writer, prevCrc uint32, pageOffset int) *encoder {
	return &encoder{
		bw:  ioutil.NewPageWriter(w, walPageBytes, pageOffset),
		crc: crc.New(prevCrc, crcTable),
		// 1MB buffer
		buf:       make([]byte, 1024*1024),
		uint64buf: make([]byte, 8),
	}
}

func  (e *encoder) encode(rec *walpb.Record)
|- e.mu.Lock()
|- //set rec.Crc
|- data = rec.Marshal
|- // padding data to force 8 bytes alignment
|- // e.bw.Write (len (data)) // TODO: really?
|- e.bw.write (data)